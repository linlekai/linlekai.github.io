(window.webpackJsonp=window.webpackJsonp||[]).push([[3],{285:function(e,t,o){"use strict";o.r(t),t.default=[{title:"打造自己的CLI",path:"/posts/node/cli.html",strippedContent:" ## 什么是CLI  CLI的英语是 Command-Line Interface,就是命令行界面。通常不支持鼠标操作，只使用键盘输入指令，计算机收到指令后执行。  与其对应的是GUI，可视化界面。可视化界面开发比较麻烦，但可以让所有人方便上手使用，而CLI适合程序员，开发容易，具有效率高，操作明确的特点。  像node出现后，像Vue、React、Angular等框架为了让使用者快速搭建项目，都是用来CLI来快速构建项目结构，免去了用户自己搭建的麻烦。  如Vue-cli 2.0 ，输入vue-cli projectname后，命令行会询问用户各种配置的信息，填写后，就能通过模板配置一些基础的文件，项目就能初始化。  ## 打造自己的CLI  我们可以打造一个自己的CLI，一个用命令行构建 .vue 文件。   大致使用方式是 ``` sh my-cli -c [name] ```  首先创建一个文件夹，我创建的名字是luke-cli，再npm init，通过npm创建一个package.json。  在package.json里添加一段代码  ```json   \"bin\": {     \"luke-cli\": \"./index.js\"   } ``` 意思是 当命令行输入luke-cli 时执行index.js  我们再创建一个index.js，之后的逻辑都在index.js里写了。  ## 需要的库  * commander 用于处理命令行 * chalk 命令行字符颜色 * inquirer 命令行回答 * fs-extra 扩展版fs * handlebars 模板引擎，用于模板填充字段 * file-exists 判断文件是否存在  vue-cli通过拉去远程仓库中模板文件再用模板引擎填充，我改成再本地读取模板，实现一个简单版。 ## 这是index.js的代码 ```js #!/usr/bin/env node const program = require('commander') // 命令行解析 const inquirer = require('inquirer') // 询问 const chalk = require('chalk') // 终端字体颜色 const fs = require('fs-extra') // fs的替代 const path = require('path') const handlebars = require('handlebars') // 模板引擎 const fileExists = require('file-exists'); // 判断文件是否存在  let cliObj = {   fileType: '.vue' } program.version('0.0.1')  program.option(   '-c, --component <name>',   'will create vue component name' )  program.on('--help', function() {   console.log('')   console.log(chalk.bold('Examples:'))   console.log(chalk.yellow.bold('  $ luke-cli -c [componentName]'))   console.log(chalk.yellow.bold('      quicky create a vue file')) })  program.parse(process.argv)  if (program.component === undefined) { } else {   console.log(`component: ${program.component}`)   cliObj.name = program.component }  inquirer   .prompt([     {       type: 'list',       name: 'templateType',       message: 'please select your template type',       default: 'default',       choices: ['simple', 'default']     }   ])   .then(answers => {     cliObj.templateType = answers.templateType     fsExists(cliObj,render)   })    function fsExists(option,callback) {   let filename = option.name + '.vue'   // 判断是否存在这个文件，如果有报错提示   fileExists(filename, (err, exists) => {     if(err) {       return console.error(err);     }else if(exists) {       // throw new Error('The current directory has the same name file')       throw new Error('该目录下有文件重复')      }     else {       callback(option)     }   }) }  function render(option) {   let data = {     name: option.name,     templateType: option.templateType,     fileType: option.fileType   }   let templateObj =     option.templateType === 'simple' ? 'simple.vue' : 'template.vue'    let source = fs.readFileSync('./' + templateObj, 'utf-8')   let template = handlebars.compile(source)    let result = template(data)   fs.writeFile(data.name + '.vue', result, err => {     if (err) throw err     console.log(chalk.bold.green('success! '))   }) }  ```   ``` html \x3c!-- 这是template.vue的代码 --\x3e <template>     <div class=\"{{name}}\">              </div> </template>  <script> export default {     name: \"{{name}}\",     data(){         return {          }     },     props:[],     created() {      },     beforeMount() {              },     mounted() {              },     beforeDestroy() {              },     destroyed() {              },     components: [] } <\/script>  <style lang=\"scss\" scoped>      </style>  ```  ```html \x3c!-- 这是simple.vue --\x3e  <template>     <div class=\"{{name}}\">              </div> </template>  <script> export default {     name: \"{{name}}\",     data(){         return {          }     } } <\/script>  <style lang=\"scss\" scoped>      </style>  ```  为方便起见，直接写在一个文件中。开头的 #!/usr/bin/env node 非常重要，是让命令行以node的形式执行这个文件。使用commander去完善命令行交互的一些功能，像 -V -help 和 -c，再使用inquirer完善一些用户的配置，具体情况可以做得更复杂些。由于我只是简单模拟一下vue-cli的功能，就只做了一个单选。配置好需要的参数后，检查是否有同名文件。如果没有就用fs读取模板文件，传入模板引擎，套入数据，最终导出文件就行。  最后在当前文件下执行sudo npm i -g，将这个文件安装到全局目录下，这样无论在哪个地方都能执行自己的命令行了。或者也可以发布到npm上。 "},{title:"快速排序",path:"/posts/algorithm/quickSort.html",strippedContent:" # 快速排序  快速排序作为排序算法里比较常见的算法，而且相对于其他的排序算法会稍微复杂一些。  快速排序这个名字是针对其性能来起的，但很难让人做到见名知意。  所以，我给它重新起了个名字：归分排序。  与归并算法一样，归分算法也是分而治之算法，讲究分、归、并。前者的重头戏在于如何去合并，后者的重头戏在于如何去划分  它的核心就是把大的东西拆分成小的，小的再拆成更小的，直到处理了再合并在一起。  ![](https://user-gold-cdn.xitu.io/2019/9/9/16d145aca98638e7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)  盗用一下大佬的图，非常形象的解释了分、归、并的原理。  快速排序一般都是使用递归去实现的，非递归的方法比较少见而且代码量会比较多。  我们再回忆一下归分算法的步骤：  1. 数组分成三部分left、pivot、right，使left<=pivot，right>pivot 2. 递归处理left 3. 递归处理right 4. 合并三者结果  这是我看到的掘金 **老姚大佬** 的非常简洁的代码，看到的第一眼就觉得短小精悍，非常巧妙。比我之前的代码要简洁太多了。  [文章地址](https://juejin.im/post/5d75b4d45188250c992d5919)  ```js function quickSort(array) {   if (array.length < 2) return array   let pivot = array[array.length - 1]   let left = array.filter((v, i) => v <= pivot && i != array.length -1)   let right = array.filter(v => v > pivot)   return [...quickSort(left), pivot, ...quickSort(right)] } ```  我自己的快排就显得非常的啰嗦了  ```js var qs = function(arr) {   if(arr.length <=1) {     return arr   }   var pivotIndex = Math.floor(arr.length / 2)   var pivot = arr.splice(pivotIndex,1)[0]   var left = [],right = []   for(let i = 0;i < arr.length; i++) {     if(arr[i] < pivot) {       left.push(arr[i])     }else {       right.push(arr[i])     }   }   return qs(left).concat([pivot],qs(right)) }  ```  "},{title:"记一次爬虫",path:"/posts/node/reptile.html",strippedContent:" ## 记一次爬虫  前段时间大学同学说想创业搞扫脸支付，需要美团嘉兴（平湖）的商家信息，问我能不能搞。我看了需要的信息觉得能搞。于是开始爬虫了。 通过接口去爬的话，确实能拿到大部分信息，但缺少最重要的商家手机号。大概率是某个字段在前端解密过才能展示手机号。所以我决定通过页面爬虫去爬。 通过无头浏览器可以实现无窗口的浏览器，使用js去操纵无头浏览器，再解析dom内容。最后将需要的内容导出成json文件。  ## puppeteer  首先介绍[puppeteer](https://pptr.dev/),它是google开发的基于Chrome内核的无头浏览器，运行在node环境，通过js可以去操纵浏览器。可以截图,测试SPA，js控制填表单，用于自动化测试。  ```js const puppeteer = require('puppeteer');  (async () => {   const browser = await puppeteer.launch();   const page = await browser.newPage();   await page.goto('https://example.com');   await page.screenshot({path: 'example.png'});    await browser.close(); })();  ```  ## 开始爬虫 * puppeteer - 无头浏览器 * cheerio - node版jQuery * fs - node文件模块 * chalk - 命令行颜色库  ---  #### 由于列表和详情是2个页面，所以要收集2个页面的信息。爬取列表的信息再打开详情页获取信息。由于列表是滚动加载，所以还得定时滚动，让它加载更多。特别注意的是：许多操作都是异步的，所以要使用await去操作，对于还没加载的数据，最好waitFor停顿一下。 ---  由于开始时的调试很顺利，也尝试爬了少量的数据。我对代码的稳定性很自信，就马上开始了大量爬取，爬了6个小时，最终快结束时由于某条数据的错误导致了程序崩溃，整个数据都没了。最后加上了简单的错误处理，报错的时候结束掉。里面有一些延迟加载和dom节点解析，然后优化了一下代码。    UserAgent也是很重要的一点，很多网站为了防爬会针对 UserAgent做处理。通常方法是我们使用浏览器去访问一次，复制浏览器的 UserAgent。 ```js const puppeteer = require('puppeteer'); const cheerio = require('cheerio'); const fs = require('fs');  // import chalk from 'chalk' const chalk = require('chalk');   (async () => {   const baseUrl = 'http://meishi.meituan.com'   let dataArray = []   let urlList = []   const browser = await puppeteer.launch({     slowMo: 1000   });   const page = await browser.newPage();   console.log(chalk.green('爬虫正常启动'))    page.setUserAgent(\"Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1\")   await page.goto(`${baseUrl}/i/?ci=185&stid_b=1&cevent=imt%2Fhomepage%2Fcategory1%2F1`);   await page.waitFor(1000);   await page.evaluate(scroll)   await page.waitFor(1000 * 60);   content = await page.content();   jqueryContent = cheerio.load(content);   jqueryContent(\".list a\").each(await newpage)  async function newpage(i,ele){     let url = jqueryContent(this).attr('href')     console.log(url)     urlList.push(baseUrl + url) }  //   await page.pdf({path: 'hn.pdf', format: 'A4'}); console.log(chalk.red(`一共需爬取${urlList.length}个数据`)) try {     await detail(urlList)        } catch (error) {     console.log(chalk.yellow('储存中。。。'))     fs.writeFileSync('商户.json',JSON.stringify(dataArray))     await browser.close();     console.log(chalk.red('----------------------------------------------'))     console.log(chalk.red('爬虫因错误结束，退出时存储内容'))     console.log(chalk.red('----------------------------------------------'))  }   console.log(chalk.yellow('储存中。。。'))   fs.writeFileSync('商户.json',JSON.stringify(dataArray))    await browser.close();    console.log(chalk.green('爬虫结束'))     async function detail(urlList) {         for(let i = 0 ;i < urlList.length;i++){             let detailPage = await browser.newPage();             detailPage.setUserAgent(\"Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1\")                     await detailPage.goto(urlList[i])             console.log(chalk.yellow(`爬取第${i+1}个,等待中。。。`))              await detailPage.click(\".phone\")             const content = await detailPage.content()                          jcontent = cheerio.load(content)             let obj = {}             // 店名             obj.name =  jcontent(\".poi-brand\").text()               // 人均             obj.price = jcontent(\".avg-price\").text()              // 地址             obj.address = jcontent(\".poi-address\").text()              // 电话             let phoneList = []             jcontent(\".msg-btn\").each(function(i) {                 phoneList.push( jcontent(this).text() )             })             obj.phoneList = phoneList             dataArray.push(obj)              // await detailPage.pdf({path: `${i}newpage.pdf`, format: 'A4'});             await detailPage.waitFor(100);             await detailPage.close();     } } })();  function scroll(){    let height = 0    let timeid= setInterval(()=>{        height += 5000        window.scroll(0,height)        if(height > 1000 * 150 ) {            clearInterval(timeid)        }     },1000) }  ```  ## 爬虫的成果  通过代码的形式去爬取美团嘉兴的数据，爬取大约几个小时获取了几万条数据，获取了商户的店名、地址、人均、手机号。如果换做是纯手工去操作的话，估计重复几次就受不了了。第一次使用puppeteer，体验还是不错的。但puppeteer只是用了基础的功能，很多高级功能还没使用过，希望哪天可以找到有趣的功能玩一玩。"},{title:"Express and Koa2",path:"/posts/node/express.html",strippedContent:" ## Express  [Express](https://expressjs.com/)和Koa都是node社区很有名的node服务器框架。他们的特点是小而灵活，具有丰富的中间件用于扩展。  # Express Demo  ```js var express = require('express'); var app = express();  app.get('/', function (req, res) {   res.send('Hello World!'); });  app.listen(3000, function () {   console.log('Example app listening on port 3000!'); }); ```  ## 中间件 中间件相当于插件函数，用于扩展Express的功能，有多种功能。建议每个中间件只专注一件事情。 Express 应用程序可以使用以下类型的中间件： * 应用层中间件 * 路由器层中间件 * 错误处理中间件 * 内置中间件 * 第三方中间件  ```js var requestTime = function (req, res, next) {   req.requestTime = Date.now();   next(); }; app.use(requestTime); ```  requestTime就是一个简单的中间件。中间件函数接收3个参数，req/res/next。它能读取到请求对象和相应对象，在中间件完成功能结束时必须调用next(),让Express进入下一个中间件。  ## 路由 ```js app.get('/', function (req, res) {   res.send('Hello World!'); }); app.post('/', function (req, res) {   res.send('Got a POST request'); }); app.put('/user', function (req, res) {   res.send('Got a PUT request at /user'); });  app.delete('/user', function (req, res) {   res.send('Got a DELETE request at /user'); }); app.all('/secret', function (req, res, next) {   console.log('Accessing the secret section ...');   next(); // pass control to the next handler });  ``` ## 模块化路由 ```js // birds.js var express = require('express'); var router = express.Router(); // middleware that is specific to this router router.use(function timeLog(req, res, next) {   console.log('Time: ', Date.now());   next(); }); // define the home page route router.get('/', function(req, res) {   res.send('Birds home page'); }); // define the about route router.get('/about', function(req, res) {   res.send('About birds'); });  module.exports = router;  ``` 将路由文件单独抽离出来，可以更清晰的维护复杂的路由。 ```js // main.js var birds = require('./birds'); app.use('/birds', birds); ```   ## 常用的第三方中间件 * [body-parser](https://github.com/expressjs/body-parser) 用于解析响应头格式 * [cookie-parser](https://github.com/expressjs/cookie-parser) 用于解析cookie  # [Koa2](https://koajs.com/)  Express和Koa都是TJ大神的杰作。Koa1.0是基于Generator的方式写的，而2.0是async/await的方式。相比于Express，Koa2更加简洁，充满async风格。  ## Koa2 Demo ```js  const Koa = require('koa'); const app = new Koa();  // logger  app.use(async (ctx, next) => {   await next();   const rt = ctx.response.get('X-Response-Time');   console.log(`${ctx.method} ${ctx.url} - ${rt}`); });  // x-response-time  app.use(async (ctx, next) => {   const start = Date.now();   await next();   const ms = Date.now() - start;   ctx.set('X-Response-Time', `${ms}ms`); });  // response  app.use(async ctx => {   ctx.body = 'Hello World'; });  app.listen(3000); ```   [Koa的中间件](https://github.com/koajs/koa/wiki)  Koa的中间件编写 ```js async function mid(ctx,next) {     // do something     await next() }  app.use(mid) ``` 我们知道 Koa 的 use 方法是支持异步的，所以为了保证正常的按照洋葱模型的执行顺序执行代码，需要在调用 next 的时候让代码等待，等待异步结束后再继续向下执行，所以我们在 Koa 中都是建议使用 async/await 的，引入的中间件都是在 use 方法中调用，由此我们可以分析出每一个 Koa 的中间件都是返回一个 async 函数的。   ## Koa源码分析 ```js module.exports = class Application extends Emitter {   /**    * Initialize a new `Application`.    *    * @api public    */    /**     *     * @param {object} [options] Application options     * @param {string} [options.env='development'] Environment     * @param {string[]} [options.keys] Signed cookie keys     * @param {boolean} [options.proxy] Trust proxy headers     * @param {number} [options.subdomainOffset] Subdomain offset     *     */    constructor(options) {     super();     options = options || {};     this.proxy = options.proxy || false;     this.subdomainOffset = options.subdomainOffset || 2;     this.env = options.env || process.env.NODE_ENV || 'development';     if (options.keys) this.keys = options.keys;     this.middleware = [];     this.context = Object.create(context);     this.request = Object.create(request);     this.response = Object.create(response);     if (util.inspect.custom) {       this[util.inspect.custom] = this.inspect;     }   } } ``` 先看局部代码，模块导出的是一个Application类,这就是 new app的类。通过options配置一些基本参数。如端口，环境，request，response。特别是中间件，特意用了数组去存放。  ```js   use(fn) {     if (typeof fn !== 'function') throw new TypeError('middleware must be a function!');     if (isGeneratorFunction(fn)) {       deprecate('Support for generators will be removed in v3. ' +                 'See the documentation for examples of how to convert old middleware ' +                 'https://github.com/koajs/koa/blob/master/docs/migration.md');       fn = convert(fn);     }     debug('use %s', fn._name || fn.name || '-');     this.middleware.push(fn);     return this;   }  ``` 实例方法use,用于增加中间件。判断fn的类型，中间件必须是一个函数，如果是普通函数，会经过转化，封装一层convert使他变成一个async函数，再push进middleware数组。return this就可以进行链式调用了。  ```js   listen(...args) {     debug('listen');     const server = http.createServer(this.callback());     return server.listen(...args);   }   callback() {     const fn = compose(this.middleware);      if (!this.listenerCount('error')) this.on('error', this.onerror);      const handleRequest = (req, res) => {       const ctx = this.createContext(req, res);       return this.handleRequest(ctx, fn);     };      return handleRequest;   } ``` 实例方法listen用于启动服务器并监听端口。关键在于callback函数是如何组合middleware的。这里有个compose，实际上是使用了koa-compose这个工具库。  我们看compose的源代码 ```js  module.exports = compose  /**  * Compose `middleware` returning  * a fully valid middleware comprised  * of all those which are passed.  *  * @param {Array} middleware  * @return {Function}  * @api public  */  function compose (middleware) {   if (!Array.isArray(middleware)) throw new TypeError('Middleware stack must be an array!')   for (const fn of middleware) {     if (typeof fn !== 'function') throw new TypeError('Middleware must be composed of functions!')   }    /**    * @param {Object} context    * @return {Promise}    * @api public    */    return function (context, next) {     // last called middleware #     let index = -1     return dispatch(0)     function dispatch (i) {       if (i <= index) return Promise.reject(new Error('next() called multiple times'))       index = i       let fn = middleware[i]       if (i === middleware.length) fn = next       if (!fn) return Promise.resolve()       try {         return Promise.resolve(fn(context, dispatch.bind(null, i + 1)));       } catch (err) {         return Promise.reject(err)       }     }    } } ``` compose接收一个数组，并用递归的形式动态创建promise。为中间件中的每个函数创建promise,并将它们一层层嵌套。从而形成洋葱圈模型。 fn就是中间件函数，第二个参数形参是next,也就是说调用next()，就会让函数递归调用一次，就进入了下一个中间件中。所以说我们在写中间件函数的时候一定要在结束时调用next函数。 "},{title:"Ajax",path:"/posts/js/ajax.html",strippedContent:' # Ajax  Ajax 全称 Asynchronous JavaScript and XML, 即异步JS与XML. 它最早在IE5中被使用, 然后由Mozilla, Apple, Google推广开来. 典型的代表应用有 Outlook Web Access, 以及 GMail. 现代网页中几乎无ajax不欢. 前后端分离也正是建立在ajax异步通信的基础之上.  ## 浏览器为ajax做了什么  标准浏览器通过 XMLHttpRequest 对象实现了ajax的功能. 只需要通过一行语句便可创建一个用于发送ajax请求的对象.  ``` js     var request = new XMLHttpRequest(); // 新建XMLHttpRequest对象;     request.onreadystatechange = function () { // 状态发生变化时，函数被回调;         if (request.readyState === 4) { // 成功完成             // 判断响应结果:             if (request.status === 200) {                 // 成功，通过responseText拿到响应的文本:             } else {                 // 失败，根据响应码判断失败原因:             }         } else {             // HTTP请求还在继续...         }     }     // 发送请求:     request.open("POST","/skill-ajax/a/login",true);     request.setRequestHeader("Content-type","application/x-www-form-urlencoded");     request.send();    // readyState值说明   // 0,初始化,XHR对象已经创建,还未执行open   // 1,载入,已经调用open方法,但是还没发送请求   // 2,载入完成,请求已经发送完成   // 3,交互,可以接收到部分数据    // status值说明   // 200:成功   // 404:没有发现文件、查询或URl   // 500:服务器产生内部错误  ``` '},{title:"原型继承和 Class 继承",path:"/posts/js/class.html",strippedContent:" # 原型继承和 Class 继承  ## 组合继承  组合继承是最常用的继承方式，  ``` js function Parent(value) {   this.val = value } Parent.prototype.getValue = function() {   console.log(this.val) } function Child(value) {   Parent.call(this, value) } Child.prototype = new Parent()  const child = new Child(1)  child.getValue() // 1 child instanceof Parent // true  ```  以上继承的方式核心是在子类的构造函数中通过 Parent.call(this) 继承父类的属性，然后改变子类的原型为 new Parent() 来继承父类的函数。  这种继承方式优点在于构造函数可以传参，不会与父类引用属性共享，可以复用父类的函数，但是也存在一个缺点就是在继承父类函数的时候调用了父类构造函数，导致子类的原型上多了不需要的父类属性，存在内存上的浪费。  ## 寄生组合继承  这种继承方式对组合继承进行了优化，组合继承缺点在于继承父类函数时调用了构造函数，我们只需要优化掉这点就行了。  ``` js function Parent(value) {   this.val = value } Parent.prototype.getValue = function() {   console.log(this.val) }  function Child(value) {   Parent.call(this, value) } Child.prototype = Object.create(Parent.prototype, {   constructor: {     value: Child,     enumerable: false,     writable: true,     configurable: true   } })  const child = new Child(1)  child.getValue() // 1 child instanceof Parent // true  ```  以上继承实现的核心就是将父类的原型赋值给了子类，并且将构造函数设置为子类，这样既解决了无用的父类属性问题，还能正确的找到子类的构造函数。  ## Class 继承  以上两种继承方式都是通过原型去解决的，在 ES6 中，我们可以使用 class 去实现继承，并且实现起来很简单 其实在 JS 中并不存在类，class 只是语法糖，本质还是函数。  ``` js class Parent {   constructor(value) {     this.val = value   }   getValue() {     console.log(this.val)   } } class Child extends Parent {   constructor(value) {     super(value)   } } let child = new Child(1) child.getValue() // 1 child instanceof Parent // true  ```  class 实现继承的核心在于使用 extends 表明继承自哪个父类，并且在子类构造函数中必须调用 super，因为这段代码可以看成 Parent.call(this, value)。  当然了，之前也说了在 JS 中并不存在类，class 的本质就是函数。"},{title:"闭包与作用域链",path:"/posts/js/closure.html",strippedContent:' # 闭包与作用域链  要理解闭包，首先必须理解Javascript特殊的变量作用域。 变量的作用域无非就是两种：全局变量和局部变量。  Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量。  ``` js 　　var n=999;  　　function f1(){ 　　　　alert(n); 　　}  　　f1(); // 999 ``` 另一方面，在函数外部自然无法读取函数内的局部变量。  ```js 　　function f1(){ 　　　　var n=999; 　　}  　　alert(n); // error ```  这里有一个地方需要注意，函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明了一个全局变量！  ```js 　　function f1(){ 　　　　n=999; 　　}  　　f1();  　　alert(n); // 999 ```  出于某些目的，我们需要获取函数内部的局部变量，通常方法是办不到的，但我们可以在函数内部再定义一个函数  ```js 　　function f1(){  　　　　var n=999;  　　　　function f2(){ 　　　　　　alert(n); // 999 　　　　}  　　}  ```  在上面的代码中，函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1就是不可见的。这就是Javascript语言特有的"链式作用域"结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。  既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！  ``` js 　　function f1(){  　　　　var n=999;  　　　　function f2(){ 　　　　　　alert(n);  　　　　}  　　　　return f2;  　　}  　　var result=f1();  　　result(); // 999 ```  闭包是指有权访问另一个函数作用域中的变量的函数。 ----《JS高级程序设计》 创建闭包的常见方式：就是在一个函数内部创建另一个函数。  闭包就是能够读取其他函数内部变量的函数。 由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成"定义在一个函数内部的函数"。 所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。  ### 使用闭包的注意点  1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。  2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。'},{title:"var、let 及 const 区别",path:"/posts/js/let.html",strippedContent:" # var、let 及 const 区别  ``` js console.log(a) // undefined var a = 1  ```  从上述代码中我们可以发现，虽然变量还没有被声明，但是我们却可以使用这个未被声明的变量，这种情况就叫做提升，并且提升的是声明。  对于这种情况，我们可以把代码这样来看  ``` js var a console.log(a) // undefined a = 1  ``` 接下来我们再来看一个例子  ``` js var a var a a = 10 console.log(a)  ```  对于这个例子，如果你认为打印的值为 undefined 那么就错了，答案应该是 10，对于这种情况，我们这样来看代码 到这里为止，我们已经了解了 var 声明的变量会发生提升的情况，其实不仅变量会提升函数也会被提升。  ``` js console.log(a) // ƒ a() {} function a() {} var a = 1  ```  对于上述代码，打印结果会是 ƒ a() {}，即使变量声明在函数之后，这也说明了函数会被提升，并且优先于变量提升。  说完了这些，想必大家也知道 var 存在的问题了，使用 var 声明的变量会被提升到作用域的顶部，接下来我们再来看 let 和 const 。  我们先来看一个例子：  ``` js var a = 1 let b = 1 const c = 1 console.log(window.b) // undefined console.log(window. c) // undefined  function test(){   console.log(a)   let a } test() ```  首先在全局作用域下使用 let 和 const 声明变量，变量并不会被挂载到 window 上，这一点就和 var 声明有了区别。  再者当我们在声明 a 之前如果使用了 a，就会出现报错的情况    你可能会认为这里也出现了提升的情况，但是因为某些原因导致不能访问。  首先报错的原因是因为存在暂时性死区，我们不能在声明前就使用变量，这也是 let 和 const 优于 var 的一点。然后这里你认为的提升和 var 的提升是有区别的，虽然变量在编译的环节中被告知在这块作用域中可以访问，但是访问是受限制的。  那么到这里，想必大家也都明白 var、let 及 const 区别了，不知道你是否会有这么一个疑问，为什么要存在提升这个事情呢，其实提升存在的根本原因就是为了解决函数间互相调用的情况  ``` js function test1() {     test2() } function test2() {     test1() } test1() ```  假如不存在提升这个情况，那么就实现不了上述的代码，因为不可能存在 test1 在 test2 前面然后 test2 又在 test1 前面。  那么最后我们总结下这小节的内容：  * 函数提升优先于变量提升，函数提升会把整个函数挪到作用域顶部，变量提升只会把声明挪到作用域顶部 * var 存在提升，我们能在声明之前使用。let、const 因为暂时性死区的原因，不能在声明前使用 * var 在全局作用域下声明变量会导致变量挂载在 window 上，其他两者不会 * let 和 const 作用基本一致，但是后者声明的变量不能再次赋值"},{title:"JS事件循环",path:"/posts/js/eventloop.html",strippedContent:" # JS事件循环  讲事件循环前，先了解执行栈。可以把执行栈理解成执行函数的栈，遵循先进后出的原则。 ![](https://user-gold-cdn.xitu.io/2018/11/13/1670d2d20ead32ec?imageslim)  执行上面的代码时，逐个将函数压入栈内，遵循后进入的函数先出来。  ## 浏览器中的 Event Loop  JS代码执行的时候就是压入栈内进行的，当遇到异步的代码的时候，会被挂起并在需要执行的时候加入到Task队列中，一旦执行栈为空，就会从Task队列中拿出需要执行的代码放入执行栈，本质上来说JS的异步还是同步行为。 不同的任务源会被分配到不同的 Task 队列中，任务源可以分为 微任务（microtask） 和 宏任务（macrotask）  MacroTask（宏任务） * script全部代码、setTimeout、setInterval、setImmediate（浏览器暂时不支持，只有IE10支持，具体可见MDN）、I/O、UI Rendering。  MicroTask（微任务） * Process.nextTick（Node独有）、Promise  ![](https://user-gold-cdn.xitu.io/2019/1/18/1686078c7a2f63e5?imageslim) 执行栈在执行完同步任务后，查看执行栈是否为空，如果执行栈为空，就会去检查微任务(microTask)队列是否为空，如果为空的话，就执行Task（宏任务），否则就一次性执行完所有微任务。 每次单个宏任务执行完毕后，检查微任务(microTask)队列是否为空，如果不为空的话，会按照先入先出的规则全部执行完微任务(microTask)后，设置微任务(microTask)队列为null，然后再执行宏任务，如此循环。  [参考地址](https://juejin.im/post/5c3d8956e51d4511dc72c200)"},{title:"new的过程以及实现new",path:"/posts/js/new.html",strippedContent:' # new的过程以及实现new  * new 通过构造函数 Test 创建出来的实例可以访问到构造函数中的属性 * new 通过构造函数 Test 创建出来的实例可以访问到构造函数原型链中的属性，也就是说通过 new 操作符，实例与构造函数通过原型链连接了起来  ```js js//方法1 function create(){    //1.创建一个空对象    let obj={}    //2.获取构造函数    let Con=[].shift.call(arguments)    //3.设置空对象的原型    obj._proto_=Con.prototype    //4.绑定this并执行构造函数，给新对象添加属性和方法    let result=Con.apply(obj,arguments)    //5.确保返回值为对象    return result instanceof Object?result:obj }  function create(con,...args) {   let obj = {}   Object.setPrototypeOf(obj,con.prototype)   let result = con.apply(obj,args)   return result instanceof Object ? result : obj }  //方法2 //通过分析原生的new方法可以看出，在new一个函数的时候， // 会返回一个func同时在这个func里面会返回一个对象Object， // 这个对象包含父类func的属性以及隐藏的__proto__ function New(f) {     //返回一个func     return function () {         var o = {"__proto__": f.prototype};         f.apply(o, arguments);//继承父类的属性         return o; //返回一个Object     } } ```  这就是一个完整的实现代码，我们通过以下几个步骤实现了它：  首先函数接受不定量的参数，第一个参数为构造函数，接下来的参数被构造函数使用 然后内部创建一个空对象 obj 因为 obj 对象需要访问到构造函数原型链上的属性，所以我们通过 setPrototypeOf 将两者联系起来。这段代码等同于 obj.__proto__ = Con.prototype 将 obj 绑定到构造函数上，并且传入剩余的参数 判断构造函数返回值是否为对象，如果为对象就使用构造函数返回的值，否则使用 obj，这样就实现了忽略构造函数返回的原始值'},{title:"Promise",path:"/posts/js/promise.html",strippedContent:" # Promise  ## 什么是 Promise  Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。  所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。 ```js new Promise(请求1)     .then(请求2(请求结果1))     .then(请求3(请求结果2))     .then(请求4(请求结果3))     .then(请求5(请求结果4))     .catch(处理异常(异常信息)) ```  ### Promise对象特点  1. 对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。 2. 一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。  ### 缺点  1. 无法取消，一旦创建它就会立即执行。无法中途取消。 2. 如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。 3. 当处于pending状态时，无法得知状态的进展（无法确定是刚开始还是快结束了）  ```js const promise = new Promise(function(resolve, reject) {   // ... some code    if (/* 异步操作成功 */){     resolve(value);   } else {     reject(error);   } }); ``` Promsie对象接受一个函数作为参数，该函数有resolve和reject这2种状态，resolve函数是状态变为成功时的，将参数传出去的。reject函数状态变为失败时将参数传出去  Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。  ```js  promise.then(function(value) {   // success }, function(error) {   // failure });  ```  ### catch  Promise.prototype.catch方法是.then(null, rejection)或.then(undefined, rejection)的别名，用于指定发生错误时的回调函数。 ```js getJSON('/posts.json').then(function(posts) {   // ... }).catch(function(error) {   // 处理 getJSON 和 前一个回调函数运行时发生的错误   console.log('发生错误！', error); });  ``` 如果异步操作出错，状态将会变为rejected，会被catch捕获，会调用catch回调函数。如果运行中报错也会被catch捕获。  ### finally  Promise.prototype.finally是不管promise的状态如何，最后都会执行的函数 ```js promise .then(result => {···}) .catch(error => {···}) .finally(() => {···}); ```  ### all Promise.all方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。  ```js const p = Promise.all([p1, p2, p3]); ``` 上面代码中，Promise.all方法接受一个数组作为参数，p1、p2、p3都是 Promise 实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。（Promise.all方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。）  p的状态由p1、p2、p3决定，分成两种情况。  （1）只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。  （2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。    # async  ES2017 标准引入了 async 函数，使得异步操作变得更加方便。  async 函数是什么？一句话，它就是 Generator 函数的语法糖。  ```js const asyncReadFile = async function () {   const f1 = await readFile('/etc/fstab');   const f2 = await readFile('/etc/shells');   console.log(f1.toString());   console.log(f2.toString()); }; ```  async函数是把多个异步操作封装成一个promise函数，而await就是内部then的语法糖。 async函数返回一个 Promise 对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。  ```js async function getStockPriceByName(name) {   const symbol = await getStockSymbol(name);   const stockPrice = await getStockPrice(symbol);   return stockPrice; }  getStockPriceByName('goog').then(function (result) {   console.log(result); }); ```  async函数的语法规则总体上比较简单，难点是错误处理机制。  async函数内部抛出错误，会导致返回的 Promise 对象变为reject状态。抛出的错误对象会被catch方法回调函数接收到。 ```js async function f() {   throw new Error('出错了'); }  f().then(   v => console.log(v),   e => console.log(e) ) // Error: 出错了 ```  await 命令后面的 Promise 对象，运行结果可能是 rejected，所以最好把 await 命令放在 try...catch 代码块中。  ```js async function myFunction() {   try {     await somethingThatReturnsAPromise();   } catch (err) {     console.log(err);   } }  // 另一种写法  async function myFunction() {   await somethingThatReturnsAPromise().catch(function (err){     console.log(err);   }); }  ``` "},{title:"JS变量类型",path:"/posts/js/type.html",strippedContent:' # JS变量类型  JavaScript 是一种弱类型脚本语言，所谓弱类型指的是定义变量时，不需要什么类型，在程序运行过程中会自动判断类型。 ECMAScript 中定义了 6 种原始类型： * Boolean * String * Number * Null * Undefined * Symbol（ES6 新定义）  和1种引用类型 * object  ::: tip 类型判断用到哪些方法？ :::  ### typeof  typeof xxx得到的值有以下几种类型：undefined boolean number string object function、symbol ，比较简单，不再一一演示了。这里需要注意的有三点：  * typeof null结果是object ，实际这是typeof的一个bug，null是原始值，非引用类型 * typeof [1, 2]结果是object，结果中没有array这一项，引用类型除了function其他的全部都是object * typeof Symbol() 用typeof获取symbol类型的值得到的是symbol，这是 ES6 新增的知识点  typeof 对于对象来说，除了函数都会显示 object，所以说 typeof 并不能准确判断变量到底是什么类型  ``` js typeof [] // \'object\' typeof {} // \'object\' typeof console.log // \'function\'  ```  ### instanceof  用于实例和构造函数的对应。例如判断一个变量是否是数组，使用typeof无法判断，但可以使用[1, 2] instanceof Array来判断。因为，[1, 2]是数组，它的构造函数就是Array。同理：  ``` js function Foo(name) {     this.name = name } var foo = new Foo(\'bar\') console.log(foo instanceof Foo) // true ```  ### instanceof 判断基本类型值的陷阱  string的这种判断方式不能准确的判断基本包装类。因此 instanceof 并不能用来判断五种基本类型值  ``` js var str = \'text\'; str instanceof String;  // false  ```  用instanceof判断Array是可行的。但不能很准确的判断出Array与Object的区别。主要原因还是由于instanceof基于原型链的判断方式去判断类型。  ``` js var arr = [1, 2, 3]; arr instanceof Array;   // true  var arr = [1, 2, 3]; arr instanceof Object;  // true // 会返回 true ，是因为 Object 构造函数的 prototype 属性存在与 arr 这个数组实例的原型链上。  ```  ### 正确判断变量类型的姿势  一个万金油方法 Object.prototype.toString.call()  Object.prototype.toString.call(variable) 用这个方法来判断变量类型目前是最可靠的了，它总能返回正确的值。该方法返回 "[object type]", 其中type是对象类型。  ``` js Object.prototype.toString.call(null);  //  "[object Null]"  Object.prototype.toString.call([]);  //  "[object Array]"  Object.prototype.toString.call({});  //  "[object Object]"  Object.prototype.toString.call(123);  //  "[object Number]"  Object.prototype.toString.call(\'123\');  //  "[object String]"  Object.prototype.toString.call(false);  //  "[object Boolean]"  Object.prototype.toString.call(undefined);  //  "[object Undefined]"  ```'},{title:"prototype 原型",path:"/posts/js/prototype.html",strippedContent:" # prototype 原型  * __proto__用来在原型链上查找你需要的方法的实际对象,所有的对象都有这个属性.这个属性被JavaScript引擎用作继承使用. 根据ECMA的规范,这个属性应该是一个内在的属性,但是大多数的浏览器厂商都允许我们去访问和修改它.  * prototype是函数独有的属性.当我们使用关键词new并且将函数作为构造函数来构造对象的时候, 它被用来构建对象的__proto__属性.  * __proto__属性和prototype属性都是一个对象  * (new A()).__proto__ === A.prototype的结果为true,(new A()).prototype === undefined的结果也为true,其中A表示一个函数(也就是构造函数)  javaScript的prototype属性是一个对象，每一个函数在定义后，都会自动获得这个属性，其初始值是一个空的对象(Object)，可以看看下面这个例子：   ```js function Dog() {     this.tail = true } Dog.prototype  // constructor: function Dog() // __proto__: Object ```  上面新建了一个名为Dog的构造函数，其prototype为一个对象，constructor和proto都是在prototype创建时，默认的自带属性，创建一个新对象时，就会带有这两个属性，无论其是否为空，例如：  ``` js var a = {} a // object //     __prototype: Objcet // a.constructor ``` 每个对象都有一个constructor,每个constructor又有一个prototype对象 例如 a对象为空对象，但在a上却有valueof方法和toString方法。这是因为a对象的prototype是Object  ## 原型链 讲原型一个不可避免的概念就是原型链，原型链是通过前面两种创建原型的方式 Object.create() 或 DOG.prototype 时生成的一个 _proto_ 指针来实现的。 ![原型链](http://upload-images.jianshu.io/upload_images/1594437-b8ecf1d9daf0e963.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)  红色的箭头就是原型链。DOG 对象有一个 prototype 对象，而实例对象 dogA 通过一个 _proto_ 对象引用这个 prototype 对象。  可以看出 dogA 能访问到的 species 属性实际上是在 DOG 的原型电源线 prototype 中，因此才能实现实例对象属性共享访问却不能修改。  但是在 DOG.prototype 中还存在一个 _proto_ 属性，这又是指向谁呢？ ![原型链](http://upload-images.jianshu.io/upload_images/1594437-08f3b7b4b12212f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)  指向 Object 对象，这样 DOG 对象就拥有 Object 对象中原型属性和方法。比如说 toString() 就在其中。  还有一点，那就是 Js 的函数也是对象啊，我们每个创建的函数其实也继承了一个函数对象，而函数则继承了 Object 对象。。  ![原型链](http://upload-images.jianshu.io/upload_images/1594437-cd1666fde005589b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)  以上就是一个简单的 Dog 类完整的原型链。  总结一下原型链作用：对象属性的访问修改和删除。 * 访问。优先在对象本身查找，没有则顺着原型链向上查找 * 修改。只能修改跟删除自身属性，不会影响到原型链上的其他对象。 "},{title:"this",path:"/posts/js/this.html",strippedContent:" # this  由于其运行期绑定的特性，JavaScript 中的 this 含义要丰富得多，它可以是全局对象、当前对象或者任意对象，这完全取决于函数的调用方式。JavaScript 中函数的调用有以下几种方式：作为对象方法调用，作为函数调用，作为构造函数调用，和使用 apply 或 call 调用。下面我们将按照调用方式的不同，分别讨论 this 的含义。   this 被分为三种情况：全局对象、当前对象或者任意对象;判断处于那种情况，这完全取决于函数的调用方式，JavaScript 中函数的调用有以下几种方式： * 作为函数调用  * 作为对象方法调用 * 作为构造函数调用 * 使用 apply 或 call 调用  ## 作为函数调用    ``` js function foo() {   console.log(this.a) } var a = 1 foo()  const obj = {   a: 2,   foo: foo } obj.foo()  var b = obj.foo b() const c = new foo()  ``` 普通函数的调用把this作为window对象的方法进行了调用，显然this指向了window对象   * 对于直接调用 foo 来说，不管 foo 函数被放在了什么地方，this 一定是 window * 对于 obj.foo() 来说，我们只需要记住，谁调用了函数，谁就是 this，所以在这个场景下 foo 函数中的 this 就是 obj 对象 * 对于 new 的方式来说，this 被永远绑定在了 c 上面，不会被任何方式改变 this  ## 作为对象方法调用  当我们调用 b() 的时候，变量b相当于window对象的一个属性，实际上是调用了 window.b() 。所以this指向的是window  ## 作为构造函数调用  ``` js function foo() {     this.name = 'hello,world' } var a = foo() console.log(a.name) // hello,world  ```  JavaScript 中的构造函数也很特殊，构造函数，其实就是通过这个函数生成一个新对象（object），这时候的 This 就会指向这个新对象；如果不使用 new 调用，则和普通函数一样。  我们使用new 构造出的 a实例，这里的this会指向实例本身  ## 使用 apply 或 call 调用  ``` js var n = 'hello world!'; function example(){ 　   console.log(this.n); 　　 } 　　 var o = {}; 　 o.n = 'hey~'; 　　 o.m = example; 　　 o.m.apply(o); //hey~ ```  使用call和apply可以改变this的指向，第一个参数为当作this的目标  ## 箭头函数的this ``` js function a() {   return () => {     return () => {       console.log(this)     }   } } console.log(a()()())  ```  首先箭头函数其实是没有 this 的，箭头函数中的 this 只取决包裹箭头函数的第一个普通函数的 this。在这个例子中，因为包裹箭头函数的第一个普通函数是 a，所以此时的 this 是 window。另外对箭头函数使用 bind 这类函数是无效的。  最后种情况也就是 bind 这些改变上下文的 API 了，对于这些函数来说，this 取决于第一个参数，如果第一个参数为空，那么就是 window。  ![this](https://cdn.nlark.com/yuque/0/2019/png/344243/1557718789230-b25eabe7-20be-4527-96cf-30a8b79925fd.png)  ### call, apply, bind区别? 怎么实现call,apply方法 ``` js jsFunction.prototype.myBind = function(content) {     if(typeof this !='function'){         throw Error('not a function')     }     let _this = this;     let args = [...arguments].slice(1)      let resFn=function(){         return _this.apply(this instanceof resFn?this:content,args.concat(...arguments))     }     return resFn };    /**  * 每个函数都可以调用call方法，来改变当前这个函数执行的this关键字，并且支持传入参数  */ Function.prototype.myCall=function(context=window){       context.fn = this;//此处this是指调用myCall的function       let args=[...arguments].slice(1);       let result=content.fn(...args)       //将this指向销毁       delete context.fn;       return result; } /**  * apply函数传入的是this指向和参数数组  */ Function.prototype.myApply = function(context=window) {     context.fn = this;     let result;     if(arguments[1]){         result=context.fn(...arguments[1])     }else{         result=context.fn()     }     //将this指向销毁     delete context.fn;     return result; }  ```"},{title:"HTML",path:"/posts/html/",strippedContent:" ## 语义化HTML是什么？有什么意义？   所谓语义化HTML，就是从代码层次表达程序员的想法、思路，同时描绘出网站页面的结构：  * 与同为人类的程序员沟通，帮助程序员快速掌握当前代码。这一点其实是可以通过注释来实现的，不过用上语义化HTML多多少少可以省点注释，哈哈。 * 与同为代码构筑的系统（例如残疾人士阅读器以及搜索引擎爬虫等）沟通，帮助其快速、准确达到目的。由于这类系统与人类的智能相比起来实在有限，因此需要协定好通过什么样的方式来进行沟通，而W3C的决议就是语义化HTML的标准了。   ## HTML新特性 * 绘画 canvas; * 用于媒介回放的 video 和 audio 元素; * 本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失; * sessionStorage 的数据在浏览器关闭后自动删除; * 语意化更好的内容元素，比如 article、footer、header、nav、section; * 表单控件，calendar、date、time、email、url、search; * 新的技术webworker, websocket, Geolocation;  移除的元素  纯表现的元素：basefont，big，center，font, s，strike，tt，u; 对可用性产生负面影响的元素：frame，frameset，noframes；   ## doctype 标准模式与兼容模式  <!doctype>声明必须处于HTML文档的头部，在标签之前，HTML5中不区分大小写,它告知浏览器的解析器用什么文档标准解析这个文档。DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现。在兼容模式中，页面以宽松的向后兼容的方式显示,模拟老式浏览器的行为以防止站点无法工作。  ## 行内元素、块级元素、空(void)元素  行内元素：行内元素不形成新内容块，即在其左右可以有其他元素，常见的有：a、span、img、b、i、em、strong、label、input、textarea、select、button、sub、sup、q  块级元素：块级元素占据其父元素（容器）横向的整个内容区域，常见的有：div、ul、ol、li、dl、dt、dd、h1-h6、p、table、form、hr、iframe、pre，html5增加的有：header、nav、section、article、aside、footer、audio、video  空元素：没有内容的 HTML 元素，常见的空元素： br、hr、img 、input 、link 、meta  ## href和src区别? title和alt  href: 指定网络资源的位置（超文本引用），从而在当前元素或者当前文档和由当前属性定义的需要的锚点或资源之间定义一个链接或者关系，在 link和a 等元素上使用 src: 属性仅仅嵌入当前资源到当前文档元素定义的位置，是页面必不可少的一部分，是引入。在 img、script、iframe 等元素上使用 title: 既是html标签，又是html属性，title作为属性时，用来为元素提供额外说明信息,通常当鼠标滑动到元素上的时候显示 alt: alt是html标签的属性，alt属性则是用来指定替换文字，只能用在img、area和input元素中（包括applet元素），用于网页中图片无法正常显示时给用户提供文字说明使其了解图像信息  ## 前端角度出发SEO * 了解搜索引擎如何抓取网页和如何索引网页 * 合理的title, meta标签优化(description, keywords) * 重要的html代码放前面 * 少用iframe, 搜索引擎不会抓取iframe中的内容 * 图片加上alt * 了解主要的搜索引擎 * 合理的标签使用 "},{title:"盒模型与box-sizing",path:"/posts/css/box.html",strippedContent:" # 盒模型与box-sizing  盒模型又称框模型（Box Model）,包含了元素内容（content）、内边距（padding）、边框（border）、外边距（margin）几个要素。  ![](https://segmentfault.com/img/remote/1460000013069519)  content-box又称标准盒模型，是浏览器的默认盒模型 标准模型元素宽度width=content，高度计算相同  ![](http://img.smyhvae.com/2015-10-03-css-27.jpg)   IE模型又称为border-box,元素宽度width=content+padding+border，高度计算相同  ![](http://img.smyhvae.com/2015-10-03-css-30.jpg)  # box-sizing 虽然box-sizing被翻译为盒尺寸，其实准确的叫法是**盒尺寸的作用细节**，或者是width的作用细节。 例如box-sizing:border-box就是把宽度直接作用在border box上，从默认的content box 变成border box。此时content box 从宽度值中释放，形成了局部流动性，和padding一起分配width"},{title:"CSS流体布局下的宽度分离原则",path:"/posts/css/flow-width-rule.html",strippedContent:" # CSS流体布局下的宽度分离原则  所谓“宽度分离原则”，就是CSS中的width属性不与影响宽度的padding/border（有时候包含margin）属性共存，也就是不能出现下面的组合 ```css .box {     width: 100px;     border: 1px solid; } 或者 .box {     width: 100px;     padding: 20px; } ```  建议的写法是 分离，width独立占用一层标签，而padding、border、margin利用流动性在内部自适应呈现  ```css .box {     width: 100px; }  .content {     padding: 20px;     border: 10px;      margin: 10px auto; } ```  ### 为什么要宽度分离  在前端领域，一提到分离。首先一定是便于维护。比如样式和行为分离，前后端分离。或者是这里的宽度分离。 由于盒尺寸中的4个盒子都能影响到宽度，自然页面元素的最终宽度很容易发生影响。  比如：  ```css .box {     width:100px;     border:1px solid; } ``` 此时的宽度为102px，当设计师希望元素边框内有20px的留白，此时我们会增加padding设置。 所以我们还得通过计算，减去原来的width来控制padding增加的像素。  ```css .box {     width: 60px;     padding: 20px;     border: 1px solid; } ```  但如果通过宽度分离原则，维护起来会非常简单。  ```css .box {     width: 102px; } .content {     border: 1px solid;     padding: 20px; } ```  维护非常简单，通过块级盒子的自动适应父级元素的宽度特性，让浏览器自动计算了"},{title:"前端工程化",path:"/posts/engineering/",strippedContent:" # 前端工程化 前端经过那么多年的发展，变化的过程非常迅速。从Node.js出现起，涌现了各种工具、框架，使得前端能解决非常多的问题。 Gulp/Grunt/Webpack 这类打包工具，使得工程化变得规范。  # 何为工程化 工程化的推进只是为了提高效率和降低成本。这里说的效率和成本，并不只是公司层面，还包括个人。良好的工程化，能降低沟通成本，实现更好的协同，节省开发和测试人员的重复劳动，降低发布的常见问题等等，经过有效实践，工程化的推广还能极大地减少加班的时间。  前端工程化所解决的问题： * 扩展 javascript 、html、css 本身的语言能力 * 解决重复工作 * 模板化、模块化 * 解决功能复用和变更问题 * 解决开发和产品环境差异问题 * 解决发布流程问题  ### 规范化  * 文档。需求文档、设计文档、系统设计、测试单、项目报告。  * 工具。开发语言选型，开发工具，协同工具，测试工具，发布工具。  * 代码规范。javascript，css，html，技术文档。  * 质量规范。功能方便，是否可拓展，是否满足 RESTFul，是否安全性满足  ### 流程化  * 软件开发常见流程  * 职责和协同  * 目标明确的版本计划  * 敏捷开发  ### 自动化  * 流程的自动化。即人员协同的自动化  * 代码开发自动化，去掉重复劳动  * 自动化单元测试  * UI/API/兼容性 自动化测试  * 自动化部署  * 自动化问题反馈  ### 创新 * 发掘其他团队的优秀方法  * 实践敏捷开发  * 多交流，多观察业界"},{title:"webpack",path:"/posts/engineering/webpack.html",strippedContent:" # [webpack](https://webpack.js.org/)   可以看做一个模块化打包机，分析项目结构，处理模块化依赖，转换成为浏览器可运行的代码。  代码转换: TypeScript 编译成 JavaScript、SCSS,LESS 编译成 CSS. 文件优化：压缩 JavaScript、CSS、HTML 代码，压缩合并图片。 代码分割：提取多个页面的公共代码、提取首屏不需要执行部分的代码让其异步加载。 模块合并：在采用模块化的项目里会有很多个模块和文件，需要构建功能把模块分类合并成一个文件。 自动刷新：监听本地源代码的变化，自动重新构建、刷新浏览器。  构建把一系列前端代码自动化去处理复杂的流程，解放生产力。  **webpack的核心概念只要记住下面四个就够用了** * 入口 * 出口 * loader * 插件   ## entry ```js module.exports = {     entry: './src',  //单入口     // or     entry: [         './src', //多入口         '/src2',     ],     // or     entry: {         main: './src', //对象写法的单入口简写     }     //or     entry: {         app: './src/index.js', //对象写法的第三方库写法         vendors: './src/script/moment.js'     }     // or     entry: {         page1: './src/page1.js',         page2: './src/page2.js',         page3: './src/page3.js',     }      }  ``` 入口就是项目代码存放的路径，webpack会把入口的文件打包。可以有多个入口  ## output  ```js module.exports = {     /*     output接受对象属性，参数为     filename: 打包后的文件名     path: 打包后所需导出的路径     */     output: {         filename: 'index.js',         path: path.resolve(__dirname, '/dist')     }     // or 多入口     entry: {         app: './src/index.js',          vendors: './src/script/moment.js'     },     output: {         filename: '[name].js',         path: __dirname + 'dist'     } }  ``` 出口指的是webpack打包完入口文件后，导出的文件  ## loader  loader是webpack的功能函数，用于处理特定文件操作的。比如typeScript转javaScript，Scss转css、bable-loader是将ES6转为ES5的。  ```js module.exports = { \t...     module: {         rules: [{             test: /\\.scss$/,             use: [{                 loader: \"style-loader\" // creates style nodes from JS strings             }, {                 loader: \"css-loader\" // translates CSS into CommonJS             }, {                 loader: \"sass-loader\" // compiles Sass to CSS             }]         }]     } };  ``` loader解析顺序是:从右向左, 上一个loader处理完的content传递给下一个loader, 一般每种loader功能是单一的  这是一个最简单的loader，函数接受content参数，content就是匹配到文件的内容，之后对文件解析，一般使用正则匹配出需要的内容，重新组合后return导出内容。这就是loader的原理。  ```js module.exports = function(content){  // content就是你要处理文件的内容,如处理App.vue文件,content就是你在App.vue写的代码     //... 中间可以对content处理     return content  // 这里你也可以用this.callback(null, content)导出 }  ```  ## plugin  扩展插件，在 Webpack 构建流程中的特定时机注入扩展逻辑来改变构建结果或做你想要的事情。  假设有一个some-webpack-plugin插件，它的使用就是下面这个样子 ```js const webpack = require('webpack');  // 假设有这么一个 webpack plugin const SomewebpackPlugin = require('some-webpack-plugin');  webpack({     // ...     plugins: [         new SomewebpackPlugin({/* some plugin options */})     ]     // ... }); ```  这个插件专门处理webpack编译过程中的某个特定任务  ### 什么样的东西能被称为webpack插件呢？  一个完整的webpack插件具有以下的特征： * 是一个独立的模块。 * 模块对外暴露一个 js 函数。 * 函数的原型 (prototype) 上定义了一个注入 compiler 对象的 apply 方法。apply 函数中需要有通过 compiler 对象挂载的 webpack 事件钩子，钩子的回调中能拿到当前编译的 compilation 对象，如果是异步编译插件的话可以拿到回调 callback。 * 完成自定义子编译流程并处理 complition 对象的内部数据。 * 如果异步编译插件的话，数据处理完成后执行 callback 回调。   ```js / 1、some-webpack-plugin.js 文件（独立模块）  // 2、模块对外暴露的 js 函数 function SomewebpackPlugin(pluginOpions) {     this.options = pluginOptions; }  // 3、原型定义一个 apply 函数，并注入了 compiler 对象 SomewebpackPlugin.prototype.apply = function (compiler) {     // 4、挂载 webpack 事件钩子（这里挂载的是 emit 事件）     compiler.plugin('emit', function (compilation, callback) {         // ... 内部进行自定义的编译操作         // 5、操作 compilation 对象的内部数据         console.log(compilation);         // 6、执行 callback 回调         callback();     }); };  // 暴露 js 函数 module.exports = SomewebpackPlugin; ```  下面是一个插件示例  ```js // MyPlugin.js  function MyPlugin(options) {     // Configure your plugin with options... }  MyPlugin.prototype.apply = function (compiler) {     compiler.plugin('compile', function (params) {         console.log('The compiler is starting to compile...');     });      compiler.plugin('compilation', function (compilation) {         console.log('The compiler is starting a new compilation...');          compilation.plugin('optimize', function () {             console.log('The compilation is starting to optimize files...');         });     });      // 异步的事件钩子     compiler.plugin('emit', function (compilation, callback) {         console.log('The compilation is going to emit files...');         callback();     }); };  module.exports = MyPlugin;  ```  [参考网站](https://zoumiaojiang.com/article/what-is-real-webpack-plugin/)"},{title:"前端框架的根本意义",path:"/posts/library/",strippedContent:" # 前端框架  ## 前端框架的根本意义  前端框架的根本意义是解决了UI 与状态同步问题  组件化: 其中以 React 的组件化最为彻底,甚至可以到函数级别的原子组件,高度的组件化可以是我们的工程易于维护、易于组合拓展。 天然分层: JQuery 时代的代码大部分情况下是面条代码,耦合严重,现代框架不管是 MVC、MVP还是MVVM 模式都能帮助我们进行分层，代码解耦更易于读写。 生态: 现在主流前端框架都自带生态,不管是数据流管理架构还是 UI 库都有成熟的解决方案  如果我们用 JQuery 或者 JS 进行操作,免不了一大堆li.appendChild、document.createElement等 DOM 操作,我们需要一长串 DOM 操作保证状态与 UI 的同步,其中一个环节出错就会导致 BUG,手动操作的缺点如下：  频繁操作 DOM 性能低下. 中间步骤过多,易产生 bug且不易维护,而且心智要求较高不利于开发效率  不管是 vue 的数据劫持、Angular 的脏检测还是 React 的组件级 reRender都是帮助我们解决 ui 与状态同步问题的利器。  ## 前端主流的三大框架  [Vue](https://cn.vuejs.org/index.html)、 [Angular](https://angular.io/)、 [React](https://reactjs.org/)"},{title:"node常用模块",path:"/posts/node/module.html",strippedContent:" # 常用模块"},{title:"vue",path:"/posts/library/vue.html",strippedContent:" # [Vue](https://cn.vuejs.org/index.html)  # 使用方法请参考官方文档  ## 响应式系统的基本原理  Vue是一个MVVM框架，当修改数据层的数据时，对应的视图层的数据也会跟着修改，同样修改视图层的数据也会对数据层的数据进行修改。这样的双向绑定，它的核心实现就是**响应式系统**。我们深入了解响应式系统。  ## Object.defineProperty  首先我们来介绍一下 Object.defineProperty，Vue.js就是基于它实现「响应式系统」的。  ```js /*     obj: 目标对象     prop: 需要操作的目标对象的属性名     descriptor: 描述符          return value 传入对象 */ Object.defineProperty(obj, prop, descriptor) ```  descriptor的一些属性 * enumerable，属性是否可枚举，默认 false。 * configurable，属性是否可以被修改或者删除，默认 false。 * get，获取属性的方法。 * set，设置属性的方法。  核心属性就是get和set  我们用最简单的例子来模拟实现。我们定义一个cb函数，当调用cb函数时就代表视图被更新了。 ```js function cb (val) {     /* 渲染视图 */     console.log(\"视图更新啦～\"); } ```  再定义defineReactive函数，用于给对象的key加上get和set。便于理解，去掉了递归绑定的情况 ```js function defineReactive (obj, key, val) {     Object.defineProperty(obj, key, {         enumerable: true,       /* 属性可枚举 */         configurable: true,     /* 属性可被修改或删除 */         get: function reactiveGetter () {             return val;         /* 实际上会依赖收集，下一小节会讲 */         },         set: function reactiveSetter (newVal) {             if (newVal === val) return;             cb(newVal);         }     }); }  function observer (value) {     if (!value || (typeof value !== 'object')) {         return;     }          Object.keys(value).forEach((key) => {         defineReactive(value, key, value[key]);     }); } ```  我们写的data数据，会在内部被_data所代理，并对data上的数据进行observer函数操作，为每个key增加了get和set。 ```js class Vue {     /* Vue构造类 */     constructor(options) {         this._data = options.data;         observer(this._data);     } } ```  ## 收集依赖  为什么要收集依赖？当我们修改了一个data里的属性，虽然在视图层里并没有使用到，但是视图还是触发更新了。这显然是不对的，我们需要的是视图层里使用到的数据发送变化的时候，才去更新。 这时候需要收集依赖来确定哪些视图层的数据使用到了数据层的数据。  ```js let globalObj = {     text1: 'text1' };  let o1 = new Vue({     template:         `<div>             <span>{{text1}}</span>          <div>`,     data: globalObj });  let o2 = new Vue({     template:         `<div>             <span>{{text1}}</span>          <div>`,     data: globalObj }); ``` 接着 ```js globalObj.text1 = 'hello,text1'; ```  我们应该需要通知 o1 以及 o2 两个vm实例进行视图的更新，「依赖收集」会让 text1 这个数据知道“哦～有两个地方依赖我的数据，我变化的时候需要通知它们～”。  ## 订阅者 Dep  首先我们来实现一个订阅者 Dep ，它的主要作用是用来存放 Watcher 观察者对象  ```js class Dep {     constructor () {         /* 用来存放Watcher对象的数组 */         this.subs = [];     }      /* 在subs中添加一个Watcher对象 */     addSub (sub) {         this.subs.push(sub);     }      /* 通知所有Watcher对象更新视图 */     notify () {         this.subs.forEach((sub) => {             sub.update();         })     } }  ```  为了便于理解我们只实现了添加的部分代码，主要是两件事情：  用 addSub 方法可以在目前的 Dep 对象中增加一个 Watcher 的订阅操作； 用 notify 方法通知目前 Dep 对象的 subs 中的所有 Watcher 对象触发更新操作。  我们修改defineReactive函数和Vue构造函数。defineReactive函数中增加Dep实例用于收集依赖 ```js function defineReactive (obj, key, val) {     /* 一个Dep类对象 */     const dep = new Dep();          Object.defineProperty(obj, key, {         enumerable: true,         configurable: true,         get: function reactiveGetter () {             /* 将Dep.target（即当前的Watcher对象存入dep的subs中） */             dep.addSub(Dep.target);             return val;                  },         set: function reactiveSetter (newVal) {             if (newVal === val) return;             /* 在set的时候触发dep的notify来通知所有的Watcher对象更新视图 */             dep.notify();         }     }); }  class Vue {     constructor(options) {         this._data = options.data;         observer(this._data);         /* 新建一个Watcher观察者对象，这时候Dep.target会指向这个Watcher对象 */         new Watcher();         /* 在这里模拟render的过程，为了触发test属性的get函数 */         console.log('render~', this._data.test);     } }  ``` ## 总结一下。  首先在 observer 的过程中会注册 get 方法，该方法用来进行「依赖收集」。在它的闭包中会有一个 Dep 对象，这个对象用来存放 Watcher 对象的实例。其实「依赖收集」的过程就是把 Watcher 实例存放到对应的 Dep 对象中去。get 方法可以让当前的 Watcher 对象（Dep.target）存放到它的 subs 中（addSub）方法，在数据变化时，set 会调用 Dep 对象的 notify 方法通知它内部所有的 Watcher 对象进行视图更新。  这是 Object.defineProperty 的 set/get 方法处理的事情，那么「依赖收集」的前提条件还有两个：  触发 get 方法； 新建一个 Watcher 对象。 这个我们在 Vue 的构造类中处理。新建一个 Watcher 对象只需要 new 出来，这时候 Dep.target 已经指向了这个 new 出来的 Watcher 对象来。而触发 get 方法也很简单，实际上只要把 render function 进行渲染，那么其中的依赖的对象都会被「读取」，这里我们通过打印来模拟这个过程，读取 test 来触发 get 进行「依赖收集」。  本章我们介绍了「依赖收集」的过程，配合之前的响应式原理，已经把整个「响应式系统」介绍完毕了。其主要就是 get 进行「依赖收集」。set 通过观察者来更新视图，配合下图仔细捋一捋，相信一定能搞懂它！  ![](https://user-gold-cdn.xitu.io/2017/12/19/1606edad5ca9e23d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)   ## Virtual DOM与VNode节点  我们知道，render function 会被转化成 VNode 节点。Virtual DOM 其实就是一棵以 JavaScript 对象（VNode 节点）作为基础的树，用对象属性来描述节点，实际上它只是一层对真实 DOM 的抽象。最终可以通过一系列操作使这棵树映射到真实环境上。由于 Virtual DOM 是以 JavaScript 对象为基础而不依赖真实平台环境  ```js class VNode {     constructor (tag, data, children, text, elm) {         /*当前节点的标签名*/         this.tag = tag;         /*当前节点的一些数据信息，比如props、attrs等数据*/         this.data = data;         /*当前节点的子节点，是一个数组*/         this.children = children;         /*当前节点的文本*/         this.text = text;         /*当前虚拟节点对应的真实dom节点*/         this.elm = elm;     } } ``` 比如我目前有这么一个 Vue 组件。  ```html <template>   <span class=\"demo\" v-show=\"isShow\">     This is a span.   </span> </template> ```  用 JavaScript 代码形式就是这样的。  ```js function render () {     return new VNode(         'span',         {             /* 指令集合数组 */             directives: [                 {                     /* v-show指令 */                     rawName: 'v-show',                     expression: 'isShow',                     name: 'show',                     value: true                 }             ],             /* 静态class */             staticClass: 'demo'         },         [ new VNode(undefined, undefined, undefined, 'This is a span.') ]     ); }  // 转化成VNode，我们用js对象来表达html标签结构，再用渲染函数构建出Dom并插入HTML中 {     tag: 'span',     data: {         /* 指令集合数组 */         directives: [             {                 /* v-show指令 */                 rawName: 'v-show',                 expression: 'isShow',                 name: 'show',                 value: true             }         ],         /* 静态class */         staticClass: 'demo'     },     text: undefined,     children: [         /* 子节点是一个文本VNode节点 */         {             tag: undefined,             data: undefined,             text: 'This is a span.',             children: undefined         }     ] }  ```  渲染函数，用于创建Dom节点和属性 ```js // 创建个空节点 function createEmptyVNode () {     const node = new VNode();     node.text = '';     return node; } // 创建个文本节点 function createTextVNode (val) {   return new VNode(undefined, undefined, undefined, String(val)); } // 复制节点 function cloneVNode (node) {     const cloneVnode = new VNode(         node.tag,         node.data,         node.children,         node.text,         node.elm     );     return cloneVnode; } ``` 总的来说，就是我们用js对象的方式表达一个节点，再用渲染函数去动态创建节点，并插入HTML中。      ## 编写Vue组件的一些建议  ### 组件可以全局或者局部加载 Vue提供2种加载组件的方式，全局加载或者局部加载。两种方法各有优势。 全局加载的组件可以从应用程序的任何模板中访问。全局加载需要谨慎，它会使你的应用膨胀，即使不使用组件，也会出现在webpack的构建中。 ```js import Vue from 'vue'; import Editor from './componetns/Editor.vue'  //Where 'editor' is the name of the component <editor></editor> Vue.component('editor', Editor); ```  局部加载组件使你能够隔离组件，并且只在必要时加载它们。当与 Webpack 结合使用时，你可以只在使用组件时延迟加载它们。这使你的应用程序初始文件较小，并减少了初始加载时间。  ### 延迟加载 / 异步组件  使用 Webpack 的动态导入来延迟加载组件。Vue 支持在渲染时延迟加载组件和代码分割。这些优化让你可以只在需要时加载组件代码，从而减少 HTTP 请求、文件大小，并自动提高性能。这个特性的重要之处在于，它既可以处理全局加载的组件，也可以处理局部加载的组件。  全局加载异步组件： ```js import Vue from 'vue';  Vue.component('editor', () => import('./componetns/Editor.vue'));  ```  本地加载异步组件：  ```js <template>   <section>     <editor></editor>   </section> </template>  <script> export default {   name: 'dashboard',   components: {     'Editor': () => import('./Editor')   } } <\/script> ```  ### 验证Props 为传入组件的props设置类型验证，会更方便开发和维护。如果传入的值与验证值不一样，vue会在浏览器控制台里警告。 ```js Vue.component('my-component', {   props: {     // 基础的类型检查 (`null` 匹配任何类型)     propA: Number,     // 多个可能的类型     propB: [String, Number],     // 必填的字符串     propC: {       type: String,       required: true     },     // 带有默认值的数字     propD: {       type: Number,       default: 100     },     // 带有默认值的对象     propE: {       type: Object,       // 对象或数组且一定会从一个工厂函数返回默认值       default: function () {         return { message: 'hello' }       }     },     // 自定义验证函数     propF: {       validator: function (value) {         // 这个值必须匹配下列字符串中的一个         return ['success', 'warning', 'danger'].indexOf(value) !== -1       }     }   } }) ``` "},{title:"npm包管理",path:"/posts/node/npm.html",strippedContent:' # npm包管理  npm有两层含义。一层含义是Node的开放式模块登记和管理系统，网址为npmjs.org。另一层含义是Node默认的模块管理器，是一个命令行下的软件，用来安装和管理Node模块。  npm不需要单独安装。在安装Node的时候，会连带一起安装npm。但是，Node附带的npm可能不是最新版本，最好用下面的命令，更新到最新版本。  ```sh  $ npm install npm@latest -g ```  ```sh # 查看 npm 命令列表 $ npm help  # 查看各个命令的简单用法 $ npm -l  # 查看 npm 的版本 $ npm -v  # 查看 npm 的配置 $ npm config list -l ```  # init npm init用来初始化生成一个新的package.json文件。它会向用户提问一系列问题，如果你觉得不用修改默认配置，一路回车就可以了。  如果使用了-f（代表force）、-y（代表yes），则跳过提问阶段，直接生成一个新的package.json文件。  # install  Node模块采用npm install命令安装。  每个模块可以“全局安装”，也可以“本地安装”。“全局安装”指的是将一个模块安装到系统目录中，各个项目都可以调用。一般来说，全局安装只适用于工具模块，比如eslint和gulp。“本地安装”指的是将一个模块下载到当前项目的node_modules子目录，然后只有在项目目录之中，才能调用这个模块。  ```sh # 本地安装 $ npm install <package name>  # 全局安装 $ sudo npm install -global <package name> $ sudo npm install -g <package name> ```  npm install也支持直接输入Github代码库地址。  ```sh $ npm install git://github.com/package/path.git $ npm install git://github.com/package/path.git#0.1.0 ```  安装之前，npm install会先检查，node_modules目录之中是否已经存在指定模块。如果存在，就不再重新安装了，即使远程仓库已经有了一个新版本，也是如此。  如果你希望，一个模块不管是否安装过，npm 都要强制重新安装，可以使用-f或--force参数  ```sh $ npm install <packageName> --force ```  如果你希望，所有模块都要强制重新安装，那就删除node_modules目录，重新执行npm install。   # run  npm不仅可以用于模块管理，还可以用于执行脚本。package.json文件有一个scripts字段，可以用于指定脚本命令，供npm直接调用。  ```json {   "name": "myproject",   "devDependencies": {     "jshint": "latest",     "browserify": "latest",     "mocha": "latest"   },   "scripts": {     "lint": "jshint **.js",     "test": "mocha test/"   } } ``` 上面代码中，scripts字段指定了两项命令lint和test。命令行输入npm run-script lint或者npm run lint，就会执行jshint **.js，输入npm run-script test或者npm run test，就会执行mocha test/。npm run是npm run-script的缩写，一般都使用前者，但是后者可以更好地反应这个命令的本质。  npm run命令会自动在环境变量$PATH添加node_modules/.bin目录，所以scripts字段里面调用命令时不用加上路径，这就避免了全局安装NPM模块。  npm run如果不加任何参数，直接运行，会列出package.json里面所有可以执行的脚本命令。  npm内置了两个命令简写，npm test等同于执行npm run test，npm start等同于执行npm run start。  npm run会创建一个Shell，执行指定的命令，并临时将node_modules/.bin加入PATH变量，这意味着本地模块可以直接运行。   写在scripts属性中的命令，也可以在node_modules/.bin目录中直接写成bash脚本。下面是一个bash脚本。  ```sh !/bin/bash  cd site/main browserify browser/main.js | uglifyjs -mc > static/bundle.js ``` 假定上面的脚本文件名为build.sh，并且权限为可执行，就可以在scripts属性中引用该文件。  ```json "build-js": "bin/build.sh" ```  # cnpm  本地电脑环境先安装node，因为安装了node就也安装了npm, 然后最好把npm装换成cnpm。方法如下： (在国内，npm操作可能会比较慢，建议使用cnpm，在淘宝镜像里面下载就行，用法和npm一样) cnpm安装地址，直接安装 npm install -g cnpm --registry=https://registry.npm.taobao.org  # yarn  Yarn 是 Facebook, Google, Exponent 和 Tilde 开发的一款新的 JavaScript 包管理工具。它并没有试图完全取代 npm。Yarn 同样是一个从 npm 注册源获取模块的新的 CLI 客户端。注册的方式不会有任何变化 —— 你同样可以正常获取与发布包。它存在的目的是解决团队在使用 npm 面临的少数问题。当然，在 Node 版本断更替中，Npm 本身也在积极更新。  安装： ```sh npm install --global yarn ```  安装默认依赖 ```sh yarn ``` 加一些依赖： ```sh yarn add gulp-less    ``` 如果加入具体版本可以后面写上@0.x.x 移除和更新 ```sh  yarn remove gulp-less   yarn upgrade [package]    ```   '}]}}]);