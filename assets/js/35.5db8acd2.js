(window.webpackJsonp=window.webpackJsonp||[]).push([[35],{321:function(e,r,t){"use strict";t.r(r);var a=t(17),n=Object(a.a)({},function(){var e=this,r=e.$createElement,t=e._self._c||r;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"前端框架"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前端框架","aria-hidden":"true"}},[e._v("#")]),e._v(" 前端框架")]),e._v(" "),t("h2",{attrs:{id:"前端框架的根本意义"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前端框架的根本意义","aria-hidden":"true"}},[e._v("#")]),e._v(" 前端框架的根本意义")]),e._v(" "),t("p",[e._v("前端框架的根本意义是解决了UI 与状态同步问题")]),e._v(" "),t("p",[e._v("组件化: 其中以 React 的组件化最为彻底,甚至可以到函数级别的原子组件,高度的组件化可以是我们的工程易于维护、易于组合拓展。\n天然分层: JQuery 时代的代码大部分情况下是面条代码,耦合严重,现代框架不管是 MVC、MVP还是MVVM 模式都能帮助我们进行分层，代码解耦更易于读写。\n生态: 现在主流前端框架都自带生态,不管是数据流管理架构还是 UI 库都有成熟的解决方案")]),e._v(" "),t("p",[e._v("如果我们用 JQuery 或者 JS 进行操作,免不了一大堆li.appendChild、document.createElement等 DOM 操作,我们需要一长串 DOM 操作保证状态与 UI 的同步,其中一个环节出错就会导致 BUG,手动操作的缺点如下：")]),e._v(" "),t("p",[e._v("频繁操作 DOM 性能低下.\n中间步骤过多,易产生 bug且不易维护,而且心智要求较高不利于开发效率")]),e._v(" "),t("p",[e._v("不管是 vue 的数据劫持、Angular 的脏检测还是 React 的组件级 reRender都是帮助我们解决 ui 与状态同步问题的利器。")]),e._v(" "),t("h2",{attrs:{id:"前端主流的三大框架"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前端主流的三大框架","aria-hidden":"true"}},[e._v("#")]),e._v(" 前端主流的三大框架")]),e._v(" "),t("p",[t("a",{attrs:{href:"https://cn.vuejs.org/index.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Vue"),t("OutboundLink")],1),e._v("、\n"),t("a",{attrs:{href:"https://angular.io/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Angular"),t("OutboundLink")],1),e._v("、\n"),t("a",{attrs:{href:"https://reactjs.org/",target:"_blank",rel:"noopener noreferrer"}},[e._v("React"),t("OutboundLink")],1)])])},[],!1,null,null,null);r.default=n.exports}}]);